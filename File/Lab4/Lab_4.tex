%-----------------------------------------------
% Assignment 4: Fundamental Image Processing Techniques Using Python
%-----------------------------------------------
\refstepcounter{section}
\addlabcontentsline{Assignment \thesection: Image Enhancement and Restoration(I)}{23-09-2025}{\thepage}
\section*{\centering Assignment \thesection: Image Enhancement and Restoration Using Python}

\noindent \textbf{Objective:} To practice spatial and frequency domain image enhancement techniques, including intensity

transformations, histogram-based processing, and filtering. This assignment emphasizes real-
world scenarios such as medical images, satellite images, and documents, along with

quantitative analysis (PSNR, SSIM, histograms).
\vspace{-1em}


%-----------------------------------------------
% Task 1
%-----------------------------------------------
\subsection{Task 1:  Brightness Adjustment and Gamma Correction}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt

# ------------------------------
# Functions
# ------------------------------
def calculate_average_brightness(image):
    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    h, s, v = cv2.split(hsv)
    return np.mean(v)

def apply_gamma_correction(image, gamma):
    table = np.array([(i / 255.0) ** gamma * 255 for i in range(256)]).astype("uint8")
    return cv2.LUT(image, table)

# ------------------------------
# Load image
# ------------------------------
image_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/CCTV1.jpg"
img = cv2.imread(image_path)

if img is None:
    print("Error: Image not found.")
    exit()

img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# ------------------------------
# Adaptive Gamma
# ------------------------------
avg_brightness = calculate_average_brightness(img)
print(f"Average Brightness = {avg_brightness:.2f}")

if avg_brightness < 100:
    gamma = 0.5
elif avg_brightness > 150:
    gamma = 1.5
else:
    gamma = 1.0

print(f"Using Gamma = {gamma}")
corrected_img = apply_gamma_correction(img, gamma)
corrected_rgb = cv2.cvtColor(corrected_img, cv2.COLOR_BGR2RGB)

# ------------------------------
# Plot Original & Gamma Corrected with Histograms
# ------------------------------
fig, axes = plt.subplots(2, 2, figsize=(14,10))

# Original Image
axes[0,0].imshow(img_rgb)
axes[0,0].set_title("Original Image")
axes[0,0].axis("off")

# Gamma Corrected Image
axes[0,1].imshow(corrected_rgb)
axes[0,1].set_title(f"Gamma Corrected (γ={gamma})")
axes[0,1].axis("off")

# Histogram Before
axes[1,0].hist(img_rgb.ravel(), 256, [0,256], color='blue')
axes[1,0].set_title("Histogram Before")

# Histogram After
axes[1,1].hist(corrected_rgb.ravel(), 256, [0,256], color='green')
axes[1,1].set_title("Histogram After")

plt.tight_layout()
plt.savefig("gamma_correction_result.png", dpi=150, bbox_inches='tight')
plt.show()

print("Saved as gamma_correction_result.png")
    
\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
Average Brightness = 73.77

Using Gamma = 0.5

\end{outputbox}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/gamma_correction_result.png}
    \caption{Gamma Correction Result}
    \label{fig:gamma_correction_result}
    \vspace{-1em}
\end{figure}
%-----------------------------------------------
% Task 2
%-----------------------------------------------
\subsection{Task 2: Histogram Equalization vs CLAHE in Medical Images.
}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr, structural_similarity as ssim

# --- 1. Load image ---
img = cv2.imread("/home/yugal/Desktop/Python Programs IP LAB/LAB 4/XRAY.jpeg", cv2.IMREAD_GRAYSCALE)

# --- 2. Global Histogram Equalization ---
global_eq = cv2.equalizeHist(img)

# --- 3. CLAHE ---
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
clahe_img = clahe.apply(img)

# --- 4. Evaluation Metrics ---
psnr_global = psnr(img, global_eq)
psnr_clahe = psnr(img, clahe_img)
ssim_global = ssim(img, global_eq)
ssim_clahe = ssim(img, clahe_img)

# === SAVE INDIVIDUAL IMAGES ===
cv2.imwrite("original_xray.png", img)
cv2.imwrite("global_equalized.png", global_eq)
cv2.imwrite("clahe_xray.png", clahe_img)

# === SAVE INDIVIDUAL HISTOGRAMS ===
def save_histogram(image, title, filename):
    plt.figure(figsize=(6,4))
    plt.hist(image.ravel(), bins=256, range=(0,256), color='black')
    plt.title(title, fontsize=12)
    plt.xlabel("Pixel Intensity")
    plt.ylabel("Frequency")
    plt.tight_layout()
    plt.savefig(filename, dpi=200, bbox_inches='tight')
    plt.close()

save_histogram(img, "Original Histogram", "hist_original.png")
save_histogram(global_eq, "Global Equalization Histogram", "hist_global.png")
save_histogram(clahe_img, "CLAHE Histogram", "hist_clahe.png")

# === SAVE SIDE-BY-SIDE COMPARISON ===
comparison = np.hstack([img, global_eq, clahe_img])
cv2.imwrite("comparison_all.png", comparison)

# --- 5. Combined Figure (as before) ---
fig, axes = plt.subplots(3,3, figsize=(18,14))
axes = axes.ravel()

axes[0].imshow(img, cmap='gray'); axes[0].set_title("Original X-ray", fontsize=14); axes[0].axis("off")
axes[1].imshow(global_eq, cmap='gray'); axes[1].set_title(f"Global HE\nPSNR={psnr_global:.2f}, SSIM={ssim_global:.3f}", fontsize=14); axes[1].axis("off")
axes[2].imshow(clahe_img, cmap='gray'); axes[2].set_title(f"CLAHE\nPSNR={psnr_clahe:.2f}, SSIM={ssim_clahe:.3f}", fontsize=14); axes[2].axis("off")

axes[3].hist(img.ravel(), bins=256, range=(0,256), color='black'); axes[3].set_title("Original Histogram", fontsize=14)
axes[4].hist(global_eq.ravel(), bins=256, range=(0,256), color='black'); axes[4].set_title("Global HE Histogram", fontsize=14)
axes[5].hist(clahe_img.ravel(), bins=256, range=(0,256), color='black'); axes[5].set_title("CLAHE Histogram", fontsize=14)

axes[6].imshow(comparison, cmap='gray'); axes[6].set_title("Original | Global HE | CLAHE", fontsize=14); axes[6].axis("off")
axes[7].axis("off"); axes[8].axis("off")

plt.tight_layout()
plt.savefig("xray_hist_comparison.png", dpi=200, bbox_inches='tight')
plt.show()

# --- 6. Print Evaluation ---
print("=== Evaluation Results ===")
print(f"Global HE -> PSNR: {psnr_global:.2f}, SSIM: {ssim_global:.3f}")
print(f"CLAHE     -> PSNR: {psnr_clahe:.2f}, SSIM: {ssim_clahe:.3f}")

if ssim_clahe > ssim_global:
    print("\nConclusion: CLAHE preserves local contrast better and is generally preferred for medical imaging (X-rays).")
else:
    print("\nConclusion: Global Histogram Equalization gives uniform contrast but may over-enhance noise.")

\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
=== Evaluation Results ===

Global HE -> PSNR: 25.41, SSIM: 0.893

CLAHE     -> PSNR: 23.88, SSIM: 0.769

Conclusion: Global Histogram Equalization gives uniform contrast but may over-enhance noise.

\end{outputbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.7\textwidth]{Lab4/original_xray.png}
    \caption{Original Xray Image}
    \label{fig:original xray}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.9\textwidth]{Lab4/hist_original.png}
    \caption{Original Xray Histogram}
    \label{fig:original xray hist}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.7\textwidth]{Lab4/global_equalized.png}
    \caption{Global Histogram Equalized Xray Image}
    \label{fig:global equalized xray}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.9\textwidth]{Lab4/hist_global.png}
    \caption{Global Histogram Equalized Xray Histogram}
    \label{fig:global equalized xray hist}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.7\textwidth]{Lab4/clahe_xray.png}
    \caption{CLAHE Xray Image}
    \label{fig:clahe xray}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.9\textwidth]{Lab4/hist_clahe.png}
    \caption{CLAHE Xray Histogram}
    \label{fig:clahe xray hist}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/comparison_all.png}
    \caption{Original GlobalHE CLAHE}
    \label{fig:comparison GlobalHE and CLAHE}
    \vspace{-1em}
\end{figure}




%-----------------------------------------------
% Task 3
%-----------------------------------------------
\subsection{Task 3: Contrast Stretching vs Histogram Equalization}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.metrics import peak_signal_noise_ratio as psnr
import os

# === 1. Load Image ===
img_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/LANDSCAPE_FADED.jpeg"
save_dir = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/"
os.makedirs(save_dir, exist_ok=True)

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

# === 2. Contrast Stretching ===
min_val, max_val = np.min(img), np.max(img)
stretched = ((img - min_val) / (max_val - min_val) * 255).astype(np.uint8)

# === 3. Histogram Equalization ===
equalized = cv2.equalizeHist(img)

# === 4. PSNR Calculation ===
psnr_stretch = psnr(img, stretched)
psnr_equal = psnr(img, equalized)

print("=== PSNR Values ===")
print(f"Contrast Stretching: {psnr_stretch:.2f}")
print(f"Histogram Equalization: {psnr_equal:.2f}")

# === 5. Save Image Results ===
cv2.imwrite(os.path.join(save_dir, "faded_landscape_original.png"), img)
cv2.imwrite(os.path.join(save_dir, "contrast_stretched_image.png"), stretched)
cv2.imwrite(os.path.join(save_dir, "histogram_equalized_image.png"), equalized)

# === 6. Plot Histograms ===
plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.hist(img.flatten(), bins=256, color='gray')
plt.title("Histogram: Original")
plt.ylim(0, 2000)

plt.subplot(1, 3, 2)
plt.hist(stretched.flatten(), bins=256, color='gray')
plt.title("Histogram: Contrast Stretched")
plt.ylim(0, 2000)

plt.subplot(1, 3, 3)
plt.hist(equalized.flatten(), bins=256, color='gray')
plt.title("Histogram: Equalized")
plt.ylim(0, 2000)

plt.tight_layout()
plt.savefig(os.path.join(save_dir, "histograms_comparison.png"), dpi=200, bbox_inches='tight')
plt.show()  

# === 7. Combined Visual Comparison ===
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(img, cmap='gray')
plt.title("Original Faded Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(stretched, cmap='gray')
plt.title("After Contrast Stretching")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(equalized, cmap='gray')
plt.title("After Histogram Equalization")
plt.axis('off')

plt.tight_layout()
plt.savefig(os.path.join(save_dir, "comparison_contrast_equalization.png"), dpi=200, bbox_inches='tight')
plt.show()  

# === 8. Reflection: When to prefer Contrast Stretching ===
reflection = """
Reflection:
Contrast Stretching performs better than Histogram Equalization when the image has
a narrow intensity range but fairly uniform distribution, such as faded or low-contrast
landscape images. It enhances contrast while preserving the natural appearance.
Histogram Equalization may over-enhance regions, amplify noise, or create unnatural
contrast in smooth areas. Therefore, for subtle enhancement and preserving visual 
look, Contrast Stretching is preferred.
"""
print(reflection)

\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}

\begin{outputbox}
=== PSNR Values ===

Contrast Stretching: 34.00

Histogram Equalization: 17.46

Reflection:
Contrast Stretching performs better than Histogram Equalization when the image has
a narrow intensity range but fairly uniform distribution, such as faded or low-contrast
landscape images. It enhances contrast while preserving the natural appearance.
Histogram Equalization may over-enhance regions, amplify noise, or create unnatural
contrast in smooth areas. Therefore, for subtle enhancement and preserving visual 
look, Contrast Stretching is preferred.


\end{outputbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/faded_landscape_original.png}
    \caption{Original Faded Landscape Image}
    \label{fig:faded_landscape_original}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/contrast_stretched_image.png}
    \caption{Contrast Stretched Image}
    \label{fig:contrast_stretched_image}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/histogram_equalized_image.png}
    \caption{Histogram Equalized Image}
    \label{fig:histogram_equalized_image}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/histograms_comparison.png}
    \caption{Histograms Comparison}
    \label{fig:histograms_comparison}
    \vspace{-1em}
\end{figure}
%-----------------------------------------------
% Task 4
%-----------------------------------------------
\subsection{Task 4: Histogram Specification (Matching)}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.exposure import match_histograms
import os

# === 1. Load Images ===
source_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/SECURITY_INPUT.jpeg"
reference_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/SECURITY_REFERENCE.jpeg"
save_dir = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/"
os.makedirs(save_dir, exist_ok=True)

source = cv2.imread(source_path, cv2.IMREAD_GRAYSCALE)
reference = cv2.imread(reference_path, cv2.IMREAD_GRAYSCALE)

# === 2. Histogram Matching ===
matched = match_histograms(source, reference, channel_axis=None).astype(np.uint8)

# === 3. Save Images ===
cv2.imwrite(os.path.join(save_dir, "security_source_image.png"), source)
cv2.imwrite(os.path.join(save_dir, "security_reference_image.png"), reference)
cv2.imwrite(os.path.join(save_dir, "matched_image.png"), matched)

# === 4. Plot Histograms ===
plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.hist(source.flatten(), bins=256, color='gray')
plt.title("Histogram: Source")
plt.ylim(0, 2000)

plt.subplot(1, 3, 2)
plt.hist(reference.flatten(), bins=256, color='gray')
plt.title("Histogram: Reference")
plt.ylim(0, 2000)

plt.subplot(1, 3, 3)
plt.hist(matched.flatten(), bins=256, color='gray')
plt.title("Histogram: Matched")
plt.ylim(0, 2000)

plt.tight_layout()
plt.savefig(os.path.join(save_dir, "histograms_matching.png"), dpi=200, bbox_inches='tight')
plt.show()

# === 5. Visual Comparison ===
plt.figure(figsize=(12, 6))

plt.subplot(1, 3, 1)
plt.imshow(source, cmap='gray')
plt.title("Source Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(reference, cmap='gray')
plt.title("Reference Image")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(matched, cmap='gray')
plt.title("Histogram Matched")
plt.axis('off')

plt.tight_layout()
plt.savefig(os.path.join(save_dir, "comparison_histogram_matching.png"), dpi=200, bbox_inches='tight')
plt.show()

# === 6. Conclusion ===
conclusion = """
Conclusion:
Histogram matching effectively adjusts the brightness and contrast of the source image
to resemble the reference image. For surveillance or security feeds, this ensures 
consistency across multiple cameras or time periods. While histogram matching improves 
visual similarity, it may not perfectly preserve local details and texture, so it works
best for global intensity adjustment rather than fine detail correction.
"""
print(conclusion)



    
\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
Conclusion:

Histogram matching effectively adjusts the brightness and contrast of the source image
to resemble the reference image. For surveillance or security feeds, this ensures 
consistency across multiple cameras or time periods. While histogram matching improves 
visual similarity, it may not perfectly preserve local details and texture, so it works
best for global intensity adjustment rather than fine detail correction.

\end{outputbox}


\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/comparison_histogram_matching.png}
    \caption{Source | Reference | Matched}
    \label{fig:comparison_histogram_matching}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/histograms_matching.png}
    \caption{Histograms Matching}
    \label{fig:histograms_matching}
    \vspace{-1em}
\end{figure}



%-----------------------------------------------
% Task 5
%-----------------------------------------------
\subsection{Task 5: Border Handling in Filtering}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
import os

# === 1. Load and Resize Image (make it 256x256) ===
img_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/SMALL_IMAGE.png"
save_dir = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/"
os.makedirs(save_dir, exist_ok=True)

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
img = cv2.resize(img, (256, 256))

# === 2. Define 3x3 Average Filter Kernel ===
kernel = np.ones((3,3), np.float32) / 9

# === 3. Apply Filter with Different Border Types ===
avg_zero = cv2.filter2D(img, -1, kernel, borderType=cv2.BORDER_CONSTANT)
avg_replicate = cv2.filter2D(img, -1, kernel, borderType=cv2.BORDER_REPLICATE)
avg_reflect = cv2.filter2D(img, -1, kernel, borderType=cv2.BORDER_REFLECT)

# For “No Padding” - crop borders manually
avg_crop = cv2.blur(img, (3,3))[1:-1, 1:-1]

# === 4. Save Results ===
cv2.imwrite(os.path.join(save_dir, "avg_zero_padding.png"), avg_zero)
cv2.imwrite(os.path.join(save_dir, "avg_replicate_padding.png"), avg_replicate)
cv2.imwrite(os.path.join(save_dir, "avg_reflect_padding.png"), avg_reflect)
cv2.imwrite(os.path.join(save_dir, "avg_crop.png"), avg_crop)

# === 5. Show All Results Together ===
titles = ["Zero Padding", "Replicate Padding", "Reflect Padding", "No Padding (Crop)"]
images = [avg_zero, avg_replicate, avg_reflect, avg_crop]

plt.figure(figsize=(12,6))
for i in range(4):
    plt.subplot(1,4,i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i], fontsize=10)
    plt.axis("off")

plt.tight_layout()
plt.savefig(os.path.join(save_dir, "border_handling_comparison.png"), dpi=200)
plt.show()

# === 6. Reflection ===
print("""
Reflection (Q5):
- Zero padding adds black borders, making edges darker.
- Replicate padding extends edge pixels and keeps borders smooth.
- Reflect padding mirrors image edges and looks very natural.
- Cropped output removes borders but reduces image size.
Conclusion: Replicate or Reflect padding usually gives the most natural results.
""")
    
\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
Reflection (Q5):

- Zero padding adds black borders, making edges darker.

- Replicate padding extends edge pixels and keeps borders smooth.

- Reflect padding mirrors image edges and looks very natural.

- Cropped output removes borders but reduces image size.

Conclusion: Replicate or Reflect padding usually gives the most natural results.

\end{outputbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/border_handling_comparison.png}
    \caption{Border Handling Comparison}
    \label{fig:border_handling_comparison}
    \vspace{-1em}
\end{figure}


%-----------------------------------------------
% Task 6
%-----------------------------------------------
\subsection{Task 6: Border Handling in Gradient and Laplacian Filtering}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
\vspace{-0.1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
import os

# === 1. Load Image ===
img_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/Edge_Image.png"
save_dir = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4/"
os.makedirs(save_dir, exist_ok=True)

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
if img is None:
    raise FileNotFoundError(f"Image not found at {img_path}")

# --- optional resize for consistent display ---
img = cv2.resize(img, (256, 256))

# --- helper: convert float64 response to displayable uint8 ---
def to_uint8(img):
    img = np.absolute(img)
    img = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX)
    return img.astype(np.uint8)

# === 2. Sobel and Laplacian with zero and replicate padding ===
sobel_x_zero = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3, borderType=cv2.BORDER_CONSTANT)
sobel_x_repl = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3, borderType=cv2.BORDER_REPLICATE)

sobel_y_zero = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3, borderType=cv2.BORDER_CONSTANT)
sobel_y_repl = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3, borderType=cv2.BORDER_REPLICATE)

lap_zero = cv2.Laplacian(img, cv2.CV_64F, ksize=3, borderType=cv2.BORDER_CONSTANT)
lap_repl = cv2.Laplacian(img, cv2.CV_64F, ksize=3, borderType=cv2.BORDER_REPLICATE)

# === 3. Simulate wrap-around manually ===
img_wrap = np.pad(img, ((1,1),(1,1)), mode='wrap')  # pad 1 pixel
sobel_x_wrap_p = cv2.Sobel(img_wrap, cv2.CV_64F, 1, 0, ksize=3, borderType=cv2.BORDER_CONSTANT)
sobel_y_wrap_p = cv2.Sobel(img_wrap, cv2.CV_64F, 0, 1, ksize=3, borderType=cv2.BORDER_CONSTANT)
lap_wrap_p     = cv2.Laplacian(img_wrap, cv2.CV_64F, ksize=3, borderType=cv2.BORDER_CONSTANT)

# crop back to original size
sobel_x_wrap = sobel_x_wrap_p[1:-1,1:-1]
sobel_y_wrap = sobel_y_wrap_p[1:-1,1:-1]
lap_wrap     = lap_wrap_p[1:-1,1:-1]

# === 4. Convert to uint8 for saving/display ===
images = {
    "sobel_x_zero": sobel_x_zero, "sobel_x_replicate": sobel_x_repl, "sobel_x_wrap": sobel_x_wrap,
    "sobel_y_zero": sobel_y_zero, "sobel_y_replicate": sobel_y_repl, "sobel_y_wrap": sobel_y_wrap,
    "laplacian_zero": lap_zero, "laplacian_replicate": lap_repl, "laplacian_wrap": lap_wrap
}

for name, imgf in images.items():
    cv2.imwrite(os.path.join(save_dir, f"{name}.png"), to_uint8(imgf))

# === 5. Visual comparison ===
titles = ['Sobel X Zero','Sobel X Replicate','Sobel X Wrap',
          'Sobel Y Zero','Sobel Y Replicate','Sobel Y Wrap',
          'Laplacian Zero','Laplacian Replicate','Laplacian Wrap']
img_list = [to_uint8(imgf) for imgf in images.values()]

plt.figure(figsize=(15,8))
for i in range(9):
    plt.subplot(3,3,i+1)
    plt.imshow(img_list[i], cmap='gray')
    plt.title(titles[i])
    plt.axis('off')
plt.tight_layout()
plt.savefig(os.path.join(save_dir,"gradient_laplacian_border_comparison.png"), dpi=200, bbox_inches='tight')
plt.show()

# === 6. Reflection ===
reflection_q6 = """
Reflection (Q6):
- Zero padding introduces artificial edges along borders.
- Replicate padding preserves edge continuity and avoids false boundaries.
- Wrap-around (simulated) connects opposite borders and can create unrealistic edges.
Conclusion: Replicate padding is generally preferred for gradient and Laplacian filtering to maintain accurate edges near image boundaries.
"""
print(reflection_q6)
    
\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
Reflection (Q6):

- Zero padding introduces artificial edges along borders.

- Replicate padding preserves edge continuity and avoids false boundaries.

- Wrap-around (simulated) connects opposite borders and can create unrealistic edges.

Conclusion: Replicate padding is generally preferred for gradient and Laplacian filtering to maintain accurate edges near image boundaries.

\end{outputbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4/gradient_laplacian_border_comparison.png}
    \caption{Gradient and Laplacian Border Handling Comparison}
    \label{fig:gradient_laplacian_border_comparison}
    \vspace{-1em}
\end{figure}


%-----------------------------------------------
% End of Assignment 3
%-----------------------------------------------