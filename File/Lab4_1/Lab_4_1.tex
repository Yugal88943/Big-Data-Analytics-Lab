%-----------------------------------------------
%%-----------------------------------------------
% Assignment 4.1: Fundamental Image Processing Techniques Using Python
%-----------------------------------------------
% Force section numbering to 4.1
\setcounter{section}{4}    % main section is 4
\renewcommand{\thesection}{4.1}  % make current section display 4.1

\section*{Assignment 4.1: Image Enhancement and Restoration Using Python}
\addcontentsline{toc}{section}{Assignment 4.1: Image Enhancement and Restoration(II) \hfill 13-10-2025}

% Reset subsection numbering to get 4.1.1, 4.1.2, ...
\setcounter{subsection}{0}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}

\noindent \textbf{Objective:} To apply image enhancement and restoration techniques for improving visibility, reducing noise, detecting edges, and analyzing contrast in grayscale and color images.
\vspace{-1em}


%-----------------------------------------------
% Task 1
%-----------------------------------------------
\subsection{Task 1:  Noise Filtering in Spatial Domain}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.util import random_noise
from math import log10, sqrt
import os

# -------------------------------
# Function to calculate PSNR
# -------------------------------
def psnr(original, filtered):
    mse = np.mean((original - filtered) ** 2)
    if mse == 0:
        return 100  # No difference
    max_pixel = 255.0
    return 20 * log10(max_pixel / sqrt(mse))

# -------------------------------
# Step 1: Load grayscale image
# -------------------------------
img_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/satellite.jpg"
save_dir = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/Results/"
os.makedirs(save_dir, exist_ok=True)

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
img = cv2.resize(img, (256, 256))
cv2.imwrite(save_dir + "original_image.png", img)

# -------------------------------
# Step 2: Add Salt and Pepper and Gaussian Noise
# -------------------------------
sp_noise = random_noise(img, mode='s\&p', amount=0.05)
sp_noise = np.array(255 * sp_noise, dtype=np.uint8)
cv2.imwrite(save_dir + "salt_pepper_noise.png", sp_noise)

gauss_noise = random_noise(img, mode='gaussian', var=0.01)
gauss_noise = np.array(255 * gauss_noise, dtype=np.uint8)
cv2.imwrite(save_dir + "gaussian_noise.png", gauss_noise)

# -------------------------------
# Step 3: Apply Filters
# -------------------------------
# Average Filter
avg_sp = cv2.blur(sp_noise, (3, 3))
avg_gauss = cv2.blur(gauss_noise, (3, 3))
cv2.imwrite(save_dir + "avg_sp.png", avg_sp)
cv2.imwrite(save_dir + "avg_gauss.png", avg_gauss)

# Gaussian Filter
gaussF_sp = cv2.GaussianBlur(sp_noise, (3, 3), 0)
gaussF_gauss = cv2.GaussianBlur(gauss_noise, (3, 3), 0)
cv2.imwrite(save_dir + "gaussF_sp.png", gaussF_sp)
cv2.imwrite(save_dir + "gaussF_gauss.png", gaussF_gauss)

# Median Filter
med_sp = cv2.medianBlur(sp_noise, 3)
med_gauss = cv2.medianBlur(gauss_noise, 3)
cv2.imwrite(save_dir + "med_sp.png", med_sp)
cv2.imwrite(save_dir + "med_gauss.png", med_gauss)

# -------------------------------
# Step 4: Calculate PSNR
# -------------------------------
psnr_sp = {
    "Average": psnr(img, avg_sp),
    "Gaussian": psnr(img, gaussF_sp),
    "Median": psnr(img, med_sp)
}

psnr_gauss = {
    "Average": psnr(img, avg_gauss),
    "Gaussian": psnr(img, gaussF_gauss),
    "Median": psnr(img, med_gauss)
}

print("\n--- PSNR for Salt and Pepper Noise ---")
for k,v in psnr_sp.items():
    print(f"{k} Filter: {v:.2f}")

print("\n--- PSNR for Gaussian Noise ---")
for k,v in psnr_gauss.items():
    print(f"{k} Filter: {v:.2f}")

# -------------------------------
# Step 5: Display Results
# -------------------------------
plt.figure(figsize=(12, 8))

plt.subplot(2,4,1), plt.imshow(sp_noise, cmap='gray'), plt.title("Salt and Pepper Noise"), plt.axis('off')
plt.subplot(2,4,2), plt.imshow(avg_sp, cmap='gray'), plt.title("Avg Filter"), plt.axis('off')
plt.subplot(2,4,3), plt.imshow(gaussF_sp, cmap='gray'), plt.title("Gaussian Filter"), plt.axis('off')
plt.subplot(2,4,4), plt.imshow(med_sp, cmap='gray'), plt.title("Median Filter"), plt.axis('off')

plt.subplot(2,4,5), plt.imshow(gauss_noise, cmap='gray'), plt.title("Gaussian Noise"), plt.axis('off')
plt.subplot(2,4,6), plt.imshow(avg_gauss, cmap='gray'), plt.title("Avg Filter"), plt.axis('off')
plt.subplot(2,4,7), plt.imshow(gaussF_gauss, cmap='gray'), plt.title("Gaussian Filter"), plt.axis('off')
plt.subplot(2,4,8), plt.imshow(med_gauss, cmap='gray'), plt.title("Median Filter"), plt.axis('off')

plt.tight_layout()
plt.savefig(save_dir + "all_filtered_results.png", dpi=200, bbox_inches='tight')
plt.show()

# -------------------------------
# Step 6: Reflection / Answer Q1
# -------------------------------
reflection_q1 = """
Reflection (Q1) - Noise Filtering:
1. Salt and Pepper Noise:
   - Median filter is most effective because it removes isolated extreme pixels without blurring edges.
   - Average or Gaussian filters tend to blur the image and cannot remove sharp salt/pepper pixels effectively.

2. Gaussian Noise:
   - Gaussian filter or Average filter works best because Gaussian noise is spread across pixels.
   - Median filter is less effective for Gaussian noise as it may slightly distort smooth areas.

Conclusion:
- Median filter - best for Salt and Pepper noise
- Gaussian / Average filter - best for Gaussian noise
"""
print(reflection_q1)
    
\end{lstlisting}

\vspace{1em} 
\subsubsection*{Output}
\begin{Numbox}
    \begin{verbatim}
       
--- PSNR for Salt and Pepper Noise ---
Average Filter: 29.21
Gaussian Filter: 29.54
Median Filter: 30.83

--- PSNR for Gaussian Noise ---
Average Filter: 29.09
Gaussian Filter: 29.21
Median Filter: 29.00

Reflection (Q1) - Noise Filtering:
1. Salt and Pepper Noise:

- Median filter is most effective because it removes isolated extreme pixels 
without blurring edges.
- Average or Gaussian filters tend to blur the image and cannot remove sharp 
salt/pepper pixels effectively.

2. Gaussian Noise:

- Gaussian filter or Average filter works best because Gaussian noise is 
spread across pixels.
- Median filter is less effective for Gaussian noise as it may slightly 
distort smooth areas.


Conclusion:
- Median filter - best for Salt and Pepper noise
- Gaussian / Average filter - best for Gaussian noise
 \end{verbatim}
\end{Numbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4_1/all_filtered_results.png}
    \caption{All Filtered Results for Salt and Pepper and Gaussian Noise}
    \label{fig:all_filtered_results}
    \vspace{-1em}
\end{figure}

%-----------------------------------------------
% Task 2
%-----------------------------------------------
\subsection{Task 2: Sharpening and Edge Detection
}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
import os

# ==============================
# 1. Load Image
# ==============================
img_path = '/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/traffic.jpg'
save_dir = '/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/Results/'
os.makedirs(save_dir, exist_ok=True)

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
img = cv2.resize(img, (512, 512))  # make image bigger for clarity
cv2.imwrite(os.path.join(save_dir, "original.png"), img)

# ==============================
# 2. Laplacian Sharpening
# ==============================
laplacian = cv2.Laplacian(img, cv2.CV_64F)
laplacian = cv2.convertScaleAbs(laplacian)
laplacian_sharp = cv2.addWeighted(img, 1.0, laplacian, -1.0, 0)
cv2.imwrite(os.path.join(save_dir, "laplacian_sharp.png"), laplacian_sharp)

# ==============================
# 3. Unsharp Masking
# ==============================
blur = cv2.GaussianBlur(img, (5, 5), 1)
unsharp = cv2.addWeighted(img, 1.5, blur, -0.5, 0)
cv2.imwrite(os.path.join(save_dir, "unsharp.png"), unsharp)

# ==============================
# 4. Canny Edge Detection
# ==============================
edges_original = cv2.Canny(img, 100, 200)
edges_laplacian = cv2.Canny(laplacian_sharp, 100, 200)
edges_unsharp = cv2.Canny(unsharp, 100, 200)

cv2.imwrite(os.path.join(save_dir, "edges_original.png"), edges_original)
cv2.imwrite(os.path.join(save_dir, "edges_laplacian.png"), edges_laplacian)
cv2.imwrite(os.path.join(save_dir, "edges_unsharp.png"), edges_unsharp)

# ==============================
# 5. Visual Comparison
# ==============================
titles = ['Original', 'Laplacian Sharpened', 'Unsharp Masking',
          'Edges - Original', 'Edges - Laplacian', 'Edges - Unsharp']
images = [img, laplacian_sharp, unsharp,
          edges_original, edges_laplacian, edges_unsharp]

plt.figure(figsize=(18, 10))  # bigger figure
for i in range(6):
    plt.subplot(2,3,i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i], fontsize=14)
    plt.axis('off')
plt.tight_layout()
plt.savefig(os.path.join(save_dir, "sharpening_edge_comparison.png"), dpi=200, bbox_inches='tight')
plt.show()

# ==============================
# 6. Edge Count Comparison
# ==============================
count_original = np.sum(edges_original > 0)
count_laplacian = np.sum(edges_laplacian > 0)
count_unsharp = np.sum(edges_unsharp > 0)

print("Edges detected (Original):", count_original)
print("Edges detected (Laplacian Sharpened):", count_laplacian)
print("Edges detected (Unsharp Masking):", count_unsharp)

# ==============================
# 7. Reflection / Conclusion
# ==============================
reflection_q2 = f"""
Reflection (Q2) - Sharpening and Edge Detection:

1. Edge Counts:
   - Original Image: {count_original}
   - Laplacian Sharpened: {count_laplacian}
   - Unsharp Masking: {count_unsharp}

2. Observations:
   - Sharpening improves the visibility of road markings.
   - Both Laplacian and Unsharp techniques increase edge detection.
   - However, some false edges may appear, especially around noise or 
   shadow regions.

3. Conclusion:
   - Sharpening is useful for improving edge clarity.
   - Use with care to avoid creating false edges.
"""
print(reflection_q2)
    
\end{lstlisting}

% \vspace{1em} 
\subsubsection*{Output}
\begin{Numbox}
    \begin{verbatim}
Edges detected (Original): 44700
Edges detected (Laplacian Sharpened): 55974
Edges detected (Unsharp Masking): 49644

Reflection (Q2) - Sharpening and Edge Detection:
1. Edge Counts:
   - Original Image: 44700
   - Laplacian Sharpened: 55974
   - Unsharp Masking: 49644
2. Observations:
   - Sharpening improves the visibility of road markings.
   - Both Laplacian and Unsharp techniques increase edge detection.
   - However, some false edges may appear, especially around noise or 
   shadow regions.
3. Conclusion:
   - Sharpening is useful for improving edge clarity.
   - Use with care to avoid creating false edges.
    \end{verbatim}
\end{Numbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/original.png}
    \caption{Traffic Original Image}
    \label{fig:Traffic_original_image}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.62\textwidth]{Lab4_1/edges_original.png}
    \caption{Traffic Edges - Original Image}
    \label{fig:edges_original}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.62\textwidth]{Lab4_1/laplacian_sharp.png}
    \caption{Traffic Edges - Laplacian Sharpened Image}
    \label{fig:sharp_edges_laplacian}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.62\textwidth]{Lab4_1/edges_laplacian.png}
    \caption{Traffic Edges - Laplacian Sharpened Image}
    \label{fig:edges_laplacian}
    \vspace{-1em}
\end{figure}

\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.62\textwidth]{Lab4_1/unsharp.png}
    \caption{Traffic Edges - Unsharp Masked Image}
    \label{fig:edges_unsharp_masked}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.62\textwidth]{Lab4_1/edges_unsharp.png}
    \caption{Traffic Edges - Unsharp Masked Image}
    \label{fig:edges_unsharp_masked_final}
    \vspace{-1em}
\end{figure}
%-----------------------------------------------
% Task 3
%-----------------------------------------------
\subsection{Task 3: Frequency Domain Filtering}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
import cv2
import numpy as np
import matplotlib.pyplot as plt
import os
# ==============================
# Step 1: Load image
# ==============================
img_path = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/LAND_New.jpg"
save_dir = "/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/Results/"
os.makedirs(save_dir, exist_ok=True)

img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
img = cv2.resize(img, (256, 256))
cv2.imwrite(os.path.join(save_dir, "original.png"), img)
# ==============================
# Step 2: Fourier Transform
# ==============================
f = np.fft.fft2(img)
fshift = np.fft.fftshift(f)
magnitude_spectrum = 20 * np.log(np.abs(fshift) + 1)
plt.imsave(os.path.join(save_dir, "fourier_spectrum.png"), magnitude_spectrum, cmap='gray')
# ==============================
# Step 3: Create filter masks
# ==============================
rows, cols = img.shape
crow, ccol = rows // 2, cols // 2

# Low-Pass Filter (LPF)
mask_lpf = np.zeros((rows, cols), np.float32)
r = 30
cv2.circle(mask_lpf, (ccol, crow), r, 1, -1)

# High-Pass Filter (HPF)
mask_hpf = 1 - mask_lpf

# Band-Stop Filter (BSF) to remove periodic noise
mask_bsf = np.ones((rows, cols), np.float32)
cv2.circle(mask_bsf, (ccol, crow), 10, 0, -1)   # remove low frequency
cv2.circle(mask_bsf, (ccol, crow), 40, 1, -1)   # allow mid/high frequencies
# ==============================
# Step 4: Apply filters in frequency domain
# ==============================
def apply_filter(fshift, mask):
    f_filtered = fshift * mask
    f_ishift = np.fft.ifftshift(f_filtered)
    img_back = np.fft.ifft2(f_ishift)
    img_back = np.abs(img_back)
    img_back = np.clip(img_back, 0, 255).astype(np.uint8)
    return img_back

img_lpf = apply_filter(fshift, mask_lpf)
img_hpf = apply_filter(fshift, mask_hpf)
img_bsf = apply_filter(fshift, mask_bsf)

cv2.imwrite(os.path.join(save_dir, "lpf.png"), img_lpf)
cv2.imwrite(os.path.join(save_dir, "hpf.png"), img_hpf)
cv2.imwrite(os.path.join(save_dir, "bsf.png"), img_bsf)
# ==============================
# Step 5: Display results
# ==============================
plt.figure(figsize=(15,8))
plt.subplot(2,3,1), plt.imshow(img, cmap='gray'), plt.title('Original'), plt.axis('off')
plt.subplot(2,3,2), plt.imshow(magnitude_spectrum, cmap='gray'), plt.title('Fourier Spectrum'), plt.axis('off')
plt.subplot(2,3,3), plt.imshow(img_lpf, cmap='gray'), plt.title('Low-Pass Filtered'), plt.axis('off')
plt.subplot(2,3,4), plt.imshow(img_hpf, cmap='gray'), plt.title('High-Pass Filtered'), plt.axis('off')
plt.subplot(2,3,5), plt.imshow(img_bsf, cmap='gray'), plt.title('Band-Stop Filtered'), plt.axis('off')
plt.tight_layout()
plt.savefig(os.path.join(save_dir, "frequency_filtered_comparison.png"), dpi=200)
plt.show()
# ==============================
# Step 6: Compare Histograms
# ==============================
plt.figure(figsize=(12,4))
plt.subplot(1,4,1), plt.hist(img.ravel(),256,[0,256]), plt.title('Original')
plt.subplot(1,4,2), plt.hist(img_lpf.ravel(),256,[0,256]), plt.title('LPF')
plt.subplot(1,4,3), plt.hist(img_hpf.ravel(),256,[0,256]), plt.title('HPF')
plt.subplot(1,4,4), plt.hist(img_bsf.ravel(),256,[0,256]), plt.title('BSF')
plt.tight_layout()
plt.savefig(os.path.join(save_dir, "histograms.png"), dpi=200)
plt.show()
# ==============================
# Step 7: Reflection / Answer
# ==============================
reflection_q3 = """
Reflection (Q3) - Frequency Domain Filtering:

1. Low-Pass Filter (LPF):
   - Smooths the image, removes high-frequency noise.
   - Image becomes blurry, edges less clear.
2. High-Pass Filter (HPF):
   - Enhances edges, but amplifies noise.
   - Useful to detect edges but not for removing periodic noise.
3. Band-Stop Filter (BSF):
   - Specifically removes periodic noise in the frequency domain.
   - Preserves most image details, edges remain clear.
   
Conclusion:
- Band-Stop Filter is most effective for removing periodic noise while maintaining visual clarity.
- LPF blurs, HPF enhances noise. BSF gives a good balance.
"""
print(reflection_q3)
    
\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
Reflection (Q3) - Frequency Domain Filtering:


1. Low-Pass Filter (LPF):

- Smooths the image, removes high-frequency noise.

- Image becomes blurry, edges less clear.

2. High-Pass Filter (HPF):

- Enhances edges, but amplifies noise.

- Useful to detect edges but not for removing periodic noise.

3. Band-Stop Filter (BSF):

- Specifically removes periodic noise in the frequency domain.

- Preserves most image details, edges remain clear.

Conclusion:

- Band-Stop Filter is most effective for removing periodic noise 
while maintaining visual clarity.

- LPF blurs, HPF enhances noise. BSF gives a good balance.

\end{outputbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4_1/histograms.png}
    \caption{Traffic Edges - Histograms}
    \label{fig:edges_histograms}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4_1/frequency_filtered_comparison.png}
    \caption{Traffic Edges - Frequency Filtered Comparison}
    \label{fig:edges_frequency_filtered_comparison}
    \vspace{-1em}
\end{figure}

%-----------------------------------------------
% Task 4: Mini-Project
%-----------------------------------------------
\subsection{Mini-Project: Low-Light Image Enhancement Using Histogram Equalization and CLAHE}


\vspace{-0.1em}
\subsubsection*{Code Implementation}
% \vspace{-1em}
\begin{lstlisting}[style=pythonStyle, caption={}]
# ============================================================
# MINI PROJECT: Image Enhancement for Low-Light Satellite Images
# ============================================================

# Author: Yugal
# Subject: Image Processing Lab
# Objective: Enhance visibility and extract meaningful detail
# ============================================================

import cv2
import numpy as np
import matplotlib.pyplot as plt
import os

# -------------------------------
# STEP 1: Load Image (Color + Grayscale)
# -------------------------------
img_path = '/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/satellite.jpg'  # <-- change path if needed
if not os.path.exists(img_path):
    raise FileNotFoundError(f"Image not found: {img_path}")

img_color = cv2.imread(img_path)
img_gray = cv2.cvtColor(img_color, cv2.COLOR_BGR2GRAY)

# Resize for easy display
img_gray = cv2.resize(img_gray, (256, 256))
img_color = cv2.resize(img_color, (256, 256))

# -------------------------------
# STEP 2: Intensity Transformations
# -------------------------------

# (a) Negative Transformation
img_negative = 255 - img_gray

# (b) Logarithmic Transformation
img_log = (255 / np.log(1 + np.max(img_gray))) * np.log(1 + img_gray)
img_log = np.array(img_log, dtype=np.uint8)

# (c) Power-Law (Gamma) Transformation
gamma = 0.5  # 0.4â€“0.6 brightens; >1 darkens
img_gamma = np.array(255 * (img_gray / 255) ** gamma, dtype='uint8')

# -------------------------------
# STEP 3: Histogram Equalization and CLAHE
# -------------------------------
img_hist = cv2.equalizeHist(img_gray)

clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
img_clahe = clahe.apply(img_gray)

# -------------------------------
# STEP 4: Filtering (Smoothing and Sharpening)
# -------------------------------
img_smooth = cv2.GaussianBlur(img_gray, (5, 5), 0)

lap = cv2.Laplacian(img_gray, cv2.CV_64F)
img_sharp = cv2.convertScaleAbs(img_gray - 0.5 * lap)

# -------------------------------
# STEP 5: Display Results
# -------------------------------
titles = [
    'Original Gray', 'Negative', 'Logarithmic', 'Gamma',
    'Histogram Equalized', 'CLAHE', 'Smoothed', 'Sharpened'
]
images = [
    img_gray, img_negative, img_log, img_gamma,
    img_hist, img_clahe, img_smooth, img_sharp
]

plt.figure(figsize=(12, 8))
for i in range(8):
    plt.subplot(2, 4, i + 1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.axis('off')
plt.tight_layout()
plt.show()

# -------------------------------
# STEP 6: Histogram Comparison
# -------------------------------
plt.figure(figsize=(10, 5))
for i, image in enumerate(images[:6]):
    plt.hist(image.ravel(), 256, [0, 256], alpha=0.5, label=titles[i])
plt.legend()
plt.title('Histogram Comparison of Enhancement Methods')
plt.xlabel('Intensity Value')
plt.ylabel('Frequency')
plt.savefig("Histogram_Comparison_of_Enhancement_Methods.png")
plt.show()

# -------------------------------
# STEP 7: Save All Output Images
# -------------------------------
output_dir = '/home/yugal/Desktop/Python Programs IP LAB/LAB 4.1/Outputs'
os.makedirs(output_dir, exist_ok=True)

outputs = {
    "gray": img_gray,
    "negative": img_negative,
    "log": img_log,
    "gamma": img_gamma,
    "hist_eq": img_hist,
    "clahe": img_clahe,
    "smooth": img_smooth,
    "sharpen": img_sharp
}

for name, image in outputs.items():
    out_path = os.path.join(output_dir, f"output_{name}.jpg")
    cv2.imwrite(out_path, image)

# -------------------------------
# STEP 8: Research Insights
# -------------------------------
print("\n================= RESEARCH INSIGHTS =================")
print("1. Log and Gamma transformations brighten low-light details effectively.")
print("2. Histogram Equalization and CLAHE improve global and local contrast.")
print("3. CLAHE + Sharpening gives best visual clarity without amplifying noise.")
print("4. Gaussian smoothing before enhancement reduces unwanted noise.")
print("=====================================================\n")
    
\end{lstlisting}

\vspace{1em} 
% \subsubsection*{Output}
\begin{outputbox}
================= RESEARCH INSIGHTS =================

1. Log and Gamma transformations brighten low-light details effectively.

2. Histogram Equalization and CLAHE improve global and local contrast.

3. CLAHE + Sharpening gives best visual clarity without amplifying noise.

4. Gaussian smoothing before enhancement reduces unwanted noise.
====================================================

\end{outputbox}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_gray.jpg}
    \caption{Original Grayscale Image}
    \label{fig:original_gray_image}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_negative.jpg}
    \caption{Negative Transformation}
    \label{fig:negative_transformation}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_log.jpg}
    \caption{Log Transformation}
    \label{fig:log_transformation}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_gamma.jpg}
    \caption{Gamma Transformation}
    \label{fig:gamma_transformation}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_hist_eq.jpg}
    \caption{Histogram Equalization}
    \label{fig:hist_equalization}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_clahe.jpg}
    \caption{Contrast Limited Adaptive Histogram Equalization (CLAHE)}
    \label{fig:clahe}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_smooth.jpg}
    \caption{Gaussian Smoothing}
    \label{fig:gaussian_smoothing}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=0.6\textwidth]{Lab4_1/output_sharpen.jpg}
    \caption{Image Sharpening}
    \label{fig:image_sharpening}
    \vspace{-1em}
\end{figure}
\begin{figure}[H]
    \centering
    % \vspace{-2em}
    \includegraphics[width=1\textwidth]{Lab4_1/Histogram_Comparison_of_Enhancement_Methods.png}
    \caption{Histogram Comparison of Enhancement Methods}
    \label{fig:histogram_comparison}
    \vspace{-1em}
\end{figure}

%-----------------------------------------------
% End of Assignment 4.1
%-----------------------------------------------